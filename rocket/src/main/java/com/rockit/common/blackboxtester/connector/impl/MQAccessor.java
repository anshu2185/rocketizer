package com.rockit.common.blackboxtester.connector.impl;import static com.rockit.common.blackboxtester.suite.configuration.SettingsHolder.cacheByConnector;import java.io.IOException;import java.util.HashMap;import java.util.Hashtable;import java.util.Map;import org.apache.commons.lang.StringUtils;import org.apache.log4j.Logger;import com.ibm.mq.MQException;import com.ibm.mq.MQGetMessageOptions;import com.ibm.mq.MQMessage;import com.ibm.mq.MQPutMessageOptions;import com.ibm.mq.MQQueue;import com.ibm.mq.MQQueueManager;import com.ibm.mq.constants.CMQC;import com.ibm.mq.constants.MQConstants;import com.rockit.common.blackboxtester.connector.settings.MQHeader;import com.rockit.common.blackboxtester.exceptions.ConnectorException;public abstract class MQAccessor {	public static final Logger LOGGER = Logger.getLogger(MQAccessor.class.getName());	static Map<String, MQQueueManager> cache = new HashMap<>();	protected String qManager;	protected String qName;	protected byte[] message;	protected String messageId;	protected String channelname;	protected int port;	protected String hostname;	private final QueueOption qOption;	private String applicationIdData;	private HashMap<String, Object> mqEnv;	public MQAccessor(final String qManager, final String qName, final int port, final String channelname,			final String hostname, final String usr, final String pwd) {						mqEnv = new HashMap<String, Object>();		mqEnv.put(MQConstants.USE_MQCSP_AUTHENTICATION_PROPERTY, false);		mqEnv.put(CMQC.CHANNEL_PROPERTY, channelname);		mqEnv.put(CMQC.HOST_NAME_PROPERTY, hostname);		mqEnv.put(CMQC.PORT_PROPERTY, new Integer(port)); // the CASE-SENSITIVE		if(StringUtils.isNotEmpty(usr) && StringUtils.isNotEmpty(pwd)) {			mqEnv.put(MQConstants.USE_MQCSP_AUTHENTICATION_PROPERTY, true);			mqEnv.put(CMQC.USER_ID_PROPERTY, usr);			mqEnv.put(CMQC.PASSWORD_PROPERTY, pwd);		}				this.qManager = qManager;		this.qName = qName;		this.qOption = QueueOption.GenerateMsgId;	}	public String get() {		String data = null;		try {			final MQQueueManager qMgr = newMQQueueManager();						final int openOptions = CMQC.MQOO_INQUIRE + CMQC.MQOO_FAIL_IF_QUIESCING + CMQC.MQOO_INPUT_SHARED + CMQC.MQGMO_PROPERTIES_AS_Q_DEF;			final MQQueue queue = qMgr.accessQueue(qName, openOptions);			final MQMessage msg = new MQMessage();			final MQGetMessageOptions gmo = new MQGetMessageOptions();			if (queue.getCurrentDepth() > 0) {				queue.get(msg, gmo);				data = msg.readStringOfByteLength(msg.getDataLength());			}			if (queue.isOpen()) {				queue.close();			}		} catch (MQException | IOException e) {			LOGGER.error("Can not read queue: " + qName, e);			throw new ConnectorException(e);		}		return data;	}	private void write(final MQQueue queue, final String name, final byte[] message) {		final MQMessage mQMsg = new MQMessage();		final MQHeader mQHeader = (MQHeader) cacheByConnector(getType(), getId());		// LOGGER.info( "MQHeader " + mQHeader.toString() );		mQMsg.characterSet = mQHeader.getCodedCharSetId();		mQMsg.format = mQHeader.getMsgFormat();		mQMsg.messageType = mQHeader.getMsgType();		mQMsg.correlationId = mQHeader.getCorrelId();		mQMsg.expiry = mQHeader.getExpiry();		mQMsg.messageId = mQHeader.getMsgId();		mQMsg.replyToQueueName = mQHeader.getReplyToQ();		mQMsg.replyToQueueManagerName = mQHeader.getReplyToQMgr();		if (name != null) {			mQMsg.messageId = name.getBytes();		}		if (applicationIdData != null && !applicationIdData.isEmpty()) {			mQMsg.applicationIdData = applicationIdData;		}		try {			mQMsg.write(message);			final MQPutMessageOptions pmo = new MQPutMessageOptions();			switch (qOption) {						case SetMsgId:				pmo.options |= CMQC.MQPMO_SET_ALL_CONTEXT;// Broker, MsgId wird gesetzt				break;							case SetMsgIdAndUserId:				pmo.options |= CMQC.MQPMO_SET_IDENTITY_CONTEXT;// Vitria, MsgId und UserId wird gesetzt									mQMsg.userId = "unknown";			default:			}			queue.put(mQMsg, pmo);			LOGGER.info("Message successfully written to " + queue.getName());		} catch (IOException | MQException ex) {			LOGGER.error("queue not be written: " + qName, ex);			throw new ConnectorException(ex);		}	}	public void putMessage(final byte[] message, final String name) {		try {			final MQQueueManager qMgr = newMQQueueManager();			int openOptions = CMQC.MQOO_OUTPUT;// Standard, MsgId wird generiert			switch (this.qOption) {			case SetMsgId:				openOptions = CMQC.MQOO_OUTPUT | CMQC.MQOO_SET_ALL_CONTEXT;// Broker, MsgId wird gesetzt																	 				break;			case SetMsgIdAndUserId:				openOptions = CMQC.MQOO_OUTPUT | CMQC.MQOO_SET_IDENTITY_CONTEXT;// Vitria, MsgId und UserId wird gesetzt				break;			default:			}			final MQQueue queue = qMgr.accessQueue(qName, openOptions);			write(queue, name, message);// Writing message into the queue			queue.close();		} catch (final MQException ex) {			LOGGER.error("can not write queue: " + qName, ex);			throw new ConnectorException(ex);		}	}	private MQQueueManager newMQQueueManager() {		if (null == cache.get(qManager)) {			LOGGER.info("Connecting MQQueueManager " + qManager);			try {				cache.put(qManager, new MQQueueManager(qManager, new Hashtable<String, Object>(mqEnv)));			} catch (final MQException e) {				LOGGER.error("MQQueueManager not available: " + qManager, e);				throw new ConnectorException(e);			}		}		return cache.get(qManager);	}		private enum QueueOption {		GenerateMsgId("GenerateMsgId"), SetMsgId("SetMsgId"), SetMsgIdAndUserId("SetMsgIdAndUserId");		private QueueOption(final String opt) {					}	}	public String getQName() {		return qName;	}	public String getMessageId() {		return messageId;	}	public void setMessageId(final String messageId) {		this.messageId = messageId;	}		@Override	public String toString() {		return "WebsphereMQ(qManager=" + this.qManager + ", qName=" + this.qName + ", hostname=" + this.hostname				+ ", port=" + this.port + ", channelname=" + this.channelname + ")";	}	public abstract String getId();	public abstract String getType();	/*	 * private void closeQueueMgr(MQQueueManager qMgr) throws MQException {	 * System.out.println("Disconnecting from the Queue Manager");	 * qMgr.disconnect(); }	 */	// private void setQueueOption(String opt) {	// QueueOption option = QueueOption.getOption(opt);	// if (option != null) {	// this.qOption = option;	// }	// }	//	// private void setApplicationIdData(String applicationIdData) {	// this.applicationIdData = applicationIdData;	// }}